// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: lifelog.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";

export const protobufPackage = "lifelog";

/** Common messages */
export interface TimeRangeRequest {
  /** ISO 8601 format */
  startTime: string;
  /** ISO 8601 format */
  endTime: string;
  /** Optional limit */
  limit: number;
  /** Optional pagination offset */
  offset: number;
}

export interface TimeStamped {
  /** ISO 8601 format */
  timestamp: string;
}

/** Search related messages */
export interface SearchRequest {
  /** Natural language or structured query */
  query: string;
  /** Which data sources to search (e.g., "screen", "camera", "process") */
  dataSources: string[];
  /** Time range to search within */
  timeRange:
    | TimeRangeRequest
    | undefined;
  /** Whether to use LLM for query processing */
  useLlm: boolean;
}

export interface SearchResult {
  /** Type of result (e.g., "screenshot", "process", "camera") */
  type: string;
  /** ISO 8601 format */
  timestamp: string;
  /** Identifier for the data source */
  sourceId: string;
  /** Additional metadata */
  metadata: { [key: string]: string };
  /** For binary data like images */
  binaryData?:
    | Uint8Array
    | undefined;
  /** For text data */
  textData?:
    | string
    | undefined;
  /** How relevant this result is to the query */
  relevanceScore: number;
}

export interface SearchResult_MetadataEntry {
  key: string;
  value: string;
}

export interface SearchResponse {
  results: SearchResult[];
  /** Total count of results (for pagination) */
  totalResults: number;
  /** ID for this search session (for pagination/refinement) */
  searchId: string;
}

/** Screenshot related messages */
export interface ScreenshotData {
  id: string;
  /** ISO 8601 format */
  timestamp: string;
  /** Binary image data */
  imageData: Uint8Array;
  /** e.g., "image/png", "image/jpeg" */
  mimeType: string;
  /** Additional metadata */
  metadata: { [key: string]: string };
}

export interface ScreenshotData_MetadataEntry {
  key: string;
  value: string;
}

/** Process related messages */
export interface ProcessData {
  id: string;
  /** ISO 8601 format */
  timestamp: string;
  processName: string;
  windowTitle: string;
  pid: number;
  /** Percentage */
  cpuUsage: number;
  /** In MB */
  memoryUsage: number;
  /** Whether this process had focus */
  isFocused: boolean;
}

export interface ProcessStatsRequest {
  timeRange:
    | TimeRangeRequest
    | undefined;
  /** Optional filter by process name */
  processName: string;
  /** Whether to aggregate stats */
  aggregate: boolean;
}

export interface ProcessStatsSummary {
  processName: string;
  /** In seconds */
  totalActiveTime: number;
  /** Percentage */
  averageCpuUsage: number;
  /** In MB */
  averageMemoryUsage: number;
  /** How many times it received focus */
  focusCount: number;
}

export interface ProcessStatsResponse {
  summaries: ProcessStatsSummary[];
  /** Usage patterns by hour */
  usageByHour: { [key: string]: number };
}

export interface ProcessStatsResponse_UsageByHourEntry {
  key: string;
  value: number;
}

/** Camera related messages */
export interface CameraFrameData {
  id: string;
  /** ISO 8601 format */
  timestamp: string;
  /** Binary image data */
  imageData: Uint8Array;
  /** e.g., "image/png", "image/jpeg" */
  mimeType: string;
  /** Additional metadata */
  metadata: { [key: string]: string };
}

export interface CameraFrameData_MetadataEntry {
  key: string;
  value: string;
}

/** Activity summary */
export interface ActivitySummary {
  timeRange: TimeRangeRequest | undefined;
  activityPeriods: ActivityPeriod[];
  /** App usage percentages */
  appUsage: { [key: string]: number };
  totalScreenshots: number;
  totalCameraFrames: number;
  /** Counts by logger type */
  totalByLogger: { [key: string]: number };
}

export interface ActivitySummary_AppUsageEntry {
  key: string;
  value: number;
}

export interface ActivitySummary_TotalByLoggerEntry {
  key: string;
  value: number;
}

export interface ActivityPeriod {
  /** ISO 8601 format */
  startTime: string;
  /** ISO 8601 format */
  endTime: string;
  /** Main activity detected */
  primaryActivity: string;
  /** Apps used during this period */
  appsUsed: { [key: string]: number };
  /** Activity level (0.0-1.0) */
  activityLevel: number;
}

export interface ActivityPeriod_AppsUsedEntry {
  key: string;
  value: number;
}

/** Authentication related messages */
export interface LoginRequest {
  username: string;
  password: string;
}

export interface LoginResponse {
  token: string;
  success: boolean;
  errorMessage: string;
  userProfile: UserProfile | undefined;
}

export interface RegisterRequest {
  username: string;
  password: string;
  email: string;
  displayName: string;
}

export interface RegisterResponse {
  success: boolean;
  errorMessage: string;
  /** Auth token if registration was successful */
  token: string;
}

export interface UserRequest {
  /** Optional, defaults to current user */
  userId: string;
}

export interface UserProfile {
  userId: string;
  username: string;
  displayName: string;
  email: string;
  /** ISO 8601 format */
  createdAt: string;
  /** User settings */
  settings: { [key: string]: boolean };
}

export interface UserProfile_SettingsEntry {
  key: string;
  value: boolean;
}

/** Logger management */
export interface LoggerStatusRequest {
  /** Optional filter, empty means all loggers */
  loggerNames: string[];
}

export interface LoggerStatus {
  /** e.g., "screen", "camera", "process" */
  name: string;
  enabled: boolean;
  running: boolean;
  /** ISO 8601 timestamp */
  lastActive: string;
  /** Number of data points collected */
  dataPoints: number;
  /** Any error message, empty if none */
  error: string;
}

export interface LoggerStatusResponse {
  loggers: LoggerStatus[];
  /** System statistics */
  systemStats: { [key: string]: string };
}

export interface LoggerStatusResponse_SystemStatsEntry {
  key: string;
  value: string;
}

export interface ToggleLoggerRequest {
  /** e.g., "screen", "camera", "process" */
  loggerName: string;
  /** true to enable, false to disable */
  enable: boolean;
}

export interface ToggleLoggerResponse {
  success: boolean;
  errorMessage: string;
  /** Updated status */
  status: LoggerStatus | undefined;
}

export interface SnapshotRequest {
  /** Which loggers to include, empty means all */
  loggers: string[];
  /** Logger-specific options */
  options: { [key: string]: string };
}

export interface SnapshotRequest_OptionsEntry {
  key: string;
  value: string;
}

export interface SnapshotResponse {
  snapshotId: string;
  success: boolean;
  errorMessage: string;
  /** Which loggers were triggered */
  triggeredLoggers: string[];
}

function createBaseTimeRangeRequest(): TimeRangeRequest {
  return { startTime: "", endTime: "", limit: 0, offset: 0 };
}

export const TimeRangeRequest: MessageFns<TimeRangeRequest> = {
  encode(message: TimeRangeRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== "") {
      writer.uint32(10).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(18).string(message.endTime);
    }
    if (message.limit !== 0) {
      writer.uint32(24).int32(message.limit);
    }
    if (message.offset !== 0) {
      writer.uint32(32).int32(message.offset);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeRangeRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeRangeRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.limit = reader.int32();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.offset = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeRangeRequest {
    return {
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
      limit: isSet(object.limit) ? globalThis.Number(object.limit) : 0,
      offset: isSet(object.offset) ? globalThis.Number(object.offset) : 0,
    };
  },

  toJSON(message: TimeRangeRequest): unknown {
    const obj: any = {};
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.limit !== 0) {
      obj.limit = Math.round(message.limit);
    }
    if (message.offset !== 0) {
      obj.offset = Math.round(message.offset);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeRangeRequest>, I>>(base?: I): TimeRangeRequest {
    return TimeRangeRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeRangeRequest>, I>>(object: I): TimeRangeRequest {
    const message = createBaseTimeRangeRequest();
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.limit = object.limit ?? 0;
    message.offset = object.offset ?? 0;
    return message;
  },
};

function createBaseTimeStamped(): TimeStamped {
  return { timestamp: "" };
}

export const TimeStamped: MessageFns<TimeStamped> = {
  encode(message: TimeStamped, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timestamp !== "") {
      writer.uint32(10).string(message.timestamp);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): TimeStamped {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseTimeStamped();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): TimeStamped {
    return { timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "" };
  },

  toJSON(message: TimeStamped): unknown {
    const obj: any = {};
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<TimeStamped>, I>>(base?: I): TimeStamped {
    return TimeStamped.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<TimeStamped>, I>>(object: I): TimeStamped {
    const message = createBaseTimeStamped();
    message.timestamp = object.timestamp ?? "";
    return message;
  },
};

function createBaseSearchRequest(): SearchRequest {
  return { query: "", dataSources: [], timeRange: undefined, useLlm: false };
}

export const SearchRequest: MessageFns<SearchRequest> = {
  encode(message: SearchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.query !== "") {
      writer.uint32(10).string(message.query);
    }
    for (const v of message.dataSources) {
      writer.uint32(18).string(v!);
    }
    if (message.timeRange !== undefined) {
      TimeRangeRequest.encode(message.timeRange, writer.uint32(26).fork()).join();
    }
    if (message.useLlm !== false) {
      writer.uint32(32).bool(message.useLlm);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.query = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.dataSources.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.timeRange = TimeRangeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.useLlm = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchRequest {
    return {
      query: isSet(object.query) ? globalThis.String(object.query) : "",
      dataSources: globalThis.Array.isArray(object?.dataSources)
        ? object.dataSources.map((e: any) => globalThis.String(e))
        : [],
      timeRange: isSet(object.timeRange) ? TimeRangeRequest.fromJSON(object.timeRange) : undefined,
      useLlm: isSet(object.useLlm) ? globalThis.Boolean(object.useLlm) : false,
    };
  },

  toJSON(message: SearchRequest): unknown {
    const obj: any = {};
    if (message.query !== "") {
      obj.query = message.query;
    }
    if (message.dataSources?.length) {
      obj.dataSources = message.dataSources;
    }
    if (message.timeRange !== undefined) {
      obj.timeRange = TimeRangeRequest.toJSON(message.timeRange);
    }
    if (message.useLlm !== false) {
      obj.useLlm = message.useLlm;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchRequest>, I>>(base?: I): SearchRequest {
    return SearchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchRequest>, I>>(object: I): SearchRequest {
    const message = createBaseSearchRequest();
    message.query = object.query ?? "";
    message.dataSources = object.dataSources?.map((e) => e) || [];
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? TimeRangeRequest.fromPartial(object.timeRange)
      : undefined;
    message.useLlm = object.useLlm ?? false;
    return message;
  },
};

function createBaseSearchResult(): SearchResult {
  return {
    type: "",
    timestamp: "",
    sourceId: "",
    metadata: {},
    binaryData: undefined,
    textData: undefined,
    relevanceScore: 0,
  };
}

export const SearchResult: MessageFns<SearchResult> = {
  encode(message: SearchResult, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.type !== "") {
      writer.uint32(10).string(message.type);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.sourceId !== "") {
      writer.uint32(26).string(message.sourceId);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      SearchResult_MetadataEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.binaryData !== undefined) {
      writer.uint32(42).bytes(message.binaryData);
    }
    if (message.textData !== undefined) {
      writer.uint32(50).string(message.textData);
    }
    if (message.relevanceScore !== 0) {
      writer.uint32(61).float(message.relevanceScore);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.sourceId = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = SearchResult_MetadataEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.metadata[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.binaryData = reader.bytes();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.textData = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.relevanceScore = reader.float();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult {
    return {
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      sourceId: isSet(object.sourceId) ? globalThis.String(object.sourceId) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
      binaryData: isSet(object.binaryData) ? bytesFromBase64(object.binaryData) : undefined,
      textData: isSet(object.textData) ? globalThis.String(object.textData) : undefined,
      relevanceScore: isSet(object.relevanceScore) ? globalThis.Number(object.relevanceScore) : 0,
    };
  },

  toJSON(message: SearchResult): unknown {
    const obj: any = {};
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.sourceId !== "") {
      obj.sourceId = message.sourceId;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    if (message.binaryData !== undefined) {
      obj.binaryData = base64FromBytes(message.binaryData);
    }
    if (message.textData !== undefined) {
      obj.textData = message.textData;
    }
    if (message.relevanceScore !== 0) {
      obj.relevanceScore = message.relevanceScore;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult>, I>>(base?: I): SearchResult {
    return SearchResult.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult>, I>>(object: I): SearchResult {
    const message = createBaseSearchResult();
    message.type = object.type ?? "";
    message.timestamp = object.timestamp ?? "";
    message.sourceId = object.sourceId ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    message.binaryData = object.binaryData ?? undefined;
    message.textData = object.textData ?? undefined;
    message.relevanceScore = object.relevanceScore ?? 0;
    return message;
  },
};

function createBaseSearchResult_MetadataEntry(): SearchResult_MetadataEntry {
  return { key: "", value: "" };
}

export const SearchResult_MetadataEntry: MessageFns<SearchResult_MetadataEntry> = {
  encode(message: SearchResult_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResult_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResult_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResult_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SearchResult_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResult_MetadataEntry>, I>>(base?: I): SearchResult_MetadataEntry {
    return SearchResult_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResult_MetadataEntry>, I>>(object: I): SearchResult_MetadataEntry {
    const message = createBaseSearchResult_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSearchResponse(): SearchResponse {
  return { results: [], totalResults: 0, searchId: "" };
}

export const SearchResponse: MessageFns<SearchResponse> = {
  encode(message: SearchResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.results) {
      SearchResult.encode(v!, writer.uint32(10).fork()).join();
    }
    if (message.totalResults !== 0) {
      writer.uint32(16).int32(message.totalResults);
    }
    if (message.searchId !== "") {
      writer.uint32(26).string(message.searchId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SearchResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSearchResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.results.push(SearchResult.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.totalResults = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.searchId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SearchResponse {
    return {
      results: globalThis.Array.isArray(object?.results)
        ? object.results.map((e: any) => SearchResult.fromJSON(e))
        : [],
      totalResults: isSet(object.totalResults) ? globalThis.Number(object.totalResults) : 0,
      searchId: isSet(object.searchId) ? globalThis.String(object.searchId) : "",
    };
  },

  toJSON(message: SearchResponse): unknown {
    const obj: any = {};
    if (message.results?.length) {
      obj.results = message.results.map((e) => SearchResult.toJSON(e));
    }
    if (message.totalResults !== 0) {
      obj.totalResults = Math.round(message.totalResults);
    }
    if (message.searchId !== "") {
      obj.searchId = message.searchId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SearchResponse>, I>>(base?: I): SearchResponse {
    return SearchResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SearchResponse>, I>>(object: I): SearchResponse {
    const message = createBaseSearchResponse();
    message.results = object.results?.map((e) => SearchResult.fromPartial(e)) || [];
    message.totalResults = object.totalResults ?? 0;
    message.searchId = object.searchId ?? "";
    return message;
  },
};

function createBaseScreenshotData(): ScreenshotData {
  return { id: "", timestamp: "", imageData: new Uint8Array(0), mimeType: "", metadata: {} };
}

export const ScreenshotData: MessageFns<ScreenshotData> = {
  encode(message: ScreenshotData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.imageData.length !== 0) {
      writer.uint32(26).bytes(message.imageData);
    }
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      ScreenshotData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenshotData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = ScreenshotData_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : new Uint8Array(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ScreenshotData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.imageData.length !== 0) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotData>, I>>(base?: I): ScreenshotData {
    return ScreenshotData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotData>, I>>(object: I): ScreenshotData {
    const message = createBaseScreenshotData();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? "";
    message.imageData = object.imageData ?? new Uint8Array(0);
    message.mimeType = object.mimeType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseScreenshotData_MetadataEntry(): ScreenshotData_MetadataEntry {
  return { key: "", value: "" };
}

export const ScreenshotData_MetadataEntry: MessageFns<ScreenshotData_MetadataEntry> = {
  encode(message: ScreenshotData_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ScreenshotData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseScreenshotData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ScreenshotData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: ScreenshotData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ScreenshotData_MetadataEntry>, I>>(base?: I): ScreenshotData_MetadataEntry {
    return ScreenshotData_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ScreenshotData_MetadataEntry>, I>>(object: I): ScreenshotData_MetadataEntry {
    const message = createBaseScreenshotData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseProcessData(): ProcessData {
  return {
    id: "",
    timestamp: "",
    processName: "",
    windowTitle: "",
    pid: 0,
    cpuUsage: 0,
    memoryUsage: 0,
    isFocused: false,
  };
}

export const ProcessData: MessageFns<ProcessData> = {
  encode(message: ProcessData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.processName !== "") {
      writer.uint32(26).string(message.processName);
    }
    if (message.windowTitle !== "") {
      writer.uint32(34).string(message.windowTitle);
    }
    if (message.pid !== 0) {
      writer.uint32(40).int32(message.pid);
    }
    if (message.cpuUsage !== 0) {
      writer.uint32(53).float(message.cpuUsage);
    }
    if (message.memoryUsage !== 0) {
      writer.uint32(61).float(message.memoryUsage);
    }
    if (message.isFocused !== false) {
      writer.uint32(64).bool(message.isFocused);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.processName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.windowTitle = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.pid = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 53) {
            break;
          }

          message.cpuUsage = reader.float();
          continue;
        }
        case 7: {
          if (tag !== 61) {
            break;
          }

          message.memoryUsage = reader.float();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.isFocused = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      processName: isSet(object.processName) ? globalThis.String(object.processName) : "",
      windowTitle: isSet(object.windowTitle) ? globalThis.String(object.windowTitle) : "",
      pid: isSet(object.pid) ? globalThis.Number(object.pid) : 0,
      cpuUsage: isSet(object.cpuUsage) ? globalThis.Number(object.cpuUsage) : 0,
      memoryUsage: isSet(object.memoryUsage) ? globalThis.Number(object.memoryUsage) : 0,
      isFocused: isSet(object.isFocused) ? globalThis.Boolean(object.isFocused) : false,
    };
  },

  toJSON(message: ProcessData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.processName !== "") {
      obj.processName = message.processName;
    }
    if (message.windowTitle !== "") {
      obj.windowTitle = message.windowTitle;
    }
    if (message.pid !== 0) {
      obj.pid = Math.round(message.pid);
    }
    if (message.cpuUsage !== 0) {
      obj.cpuUsage = message.cpuUsage;
    }
    if (message.memoryUsage !== 0) {
      obj.memoryUsage = message.memoryUsage;
    }
    if (message.isFocused !== false) {
      obj.isFocused = message.isFocused;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessData>, I>>(base?: I): ProcessData {
    return ProcessData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessData>, I>>(object: I): ProcessData {
    const message = createBaseProcessData();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? "";
    message.processName = object.processName ?? "";
    message.windowTitle = object.windowTitle ?? "";
    message.pid = object.pid ?? 0;
    message.cpuUsage = object.cpuUsage ?? 0;
    message.memoryUsage = object.memoryUsage ?? 0;
    message.isFocused = object.isFocused ?? false;
    return message;
  },
};

function createBaseProcessStatsRequest(): ProcessStatsRequest {
  return { timeRange: undefined, processName: "", aggregate: false };
}

export const ProcessStatsRequest: MessageFns<ProcessStatsRequest> = {
  encode(message: ProcessStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeRange !== undefined) {
      TimeRangeRequest.encode(message.timeRange, writer.uint32(10).fork()).join();
    }
    if (message.processName !== "") {
      writer.uint32(18).string(message.processName);
    }
    if (message.aggregate !== false) {
      writer.uint32(24).bool(message.aggregate);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeRange = TimeRangeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.processName = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.aggregate = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessStatsRequest {
    return {
      timeRange: isSet(object.timeRange) ? TimeRangeRequest.fromJSON(object.timeRange) : undefined,
      processName: isSet(object.processName) ? globalThis.String(object.processName) : "",
      aggregate: isSet(object.aggregate) ? globalThis.Boolean(object.aggregate) : false,
    };
  },

  toJSON(message: ProcessStatsRequest): unknown {
    const obj: any = {};
    if (message.timeRange !== undefined) {
      obj.timeRange = TimeRangeRequest.toJSON(message.timeRange);
    }
    if (message.processName !== "") {
      obj.processName = message.processName;
    }
    if (message.aggregate !== false) {
      obj.aggregate = message.aggregate;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessStatsRequest>, I>>(base?: I): ProcessStatsRequest {
    return ProcessStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessStatsRequest>, I>>(object: I): ProcessStatsRequest {
    const message = createBaseProcessStatsRequest();
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? TimeRangeRequest.fromPartial(object.timeRange)
      : undefined;
    message.processName = object.processName ?? "";
    message.aggregate = object.aggregate ?? false;
    return message;
  },
};

function createBaseProcessStatsSummary(): ProcessStatsSummary {
  return { processName: "", totalActiveTime: 0, averageCpuUsage: 0, averageMemoryUsage: 0, focusCount: 0 };
}

export const ProcessStatsSummary: MessageFns<ProcessStatsSummary> = {
  encode(message: ProcessStatsSummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.processName !== "") {
      writer.uint32(10).string(message.processName);
    }
    if (message.totalActiveTime !== 0) {
      writer.uint32(17).double(message.totalActiveTime);
    }
    if (message.averageCpuUsage !== 0) {
      writer.uint32(25).double(message.averageCpuUsage);
    }
    if (message.averageMemoryUsage !== 0) {
      writer.uint32(33).double(message.averageMemoryUsage);
    }
    if (message.focusCount !== 0) {
      writer.uint32(40).int32(message.focusCount);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessStatsSummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessStatsSummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.processName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.totalActiveTime = reader.double();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.averageCpuUsage = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 33) {
            break;
          }

          message.averageMemoryUsage = reader.double();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.focusCount = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessStatsSummary {
    return {
      processName: isSet(object.processName) ? globalThis.String(object.processName) : "",
      totalActiveTime: isSet(object.totalActiveTime) ? globalThis.Number(object.totalActiveTime) : 0,
      averageCpuUsage: isSet(object.averageCpuUsage) ? globalThis.Number(object.averageCpuUsage) : 0,
      averageMemoryUsage: isSet(object.averageMemoryUsage) ? globalThis.Number(object.averageMemoryUsage) : 0,
      focusCount: isSet(object.focusCount) ? globalThis.Number(object.focusCount) : 0,
    };
  },

  toJSON(message: ProcessStatsSummary): unknown {
    const obj: any = {};
    if (message.processName !== "") {
      obj.processName = message.processName;
    }
    if (message.totalActiveTime !== 0) {
      obj.totalActiveTime = message.totalActiveTime;
    }
    if (message.averageCpuUsage !== 0) {
      obj.averageCpuUsage = message.averageCpuUsage;
    }
    if (message.averageMemoryUsage !== 0) {
      obj.averageMemoryUsage = message.averageMemoryUsage;
    }
    if (message.focusCount !== 0) {
      obj.focusCount = Math.round(message.focusCount);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessStatsSummary>, I>>(base?: I): ProcessStatsSummary {
    return ProcessStatsSummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessStatsSummary>, I>>(object: I): ProcessStatsSummary {
    const message = createBaseProcessStatsSummary();
    message.processName = object.processName ?? "";
    message.totalActiveTime = object.totalActiveTime ?? 0;
    message.averageCpuUsage = object.averageCpuUsage ?? 0;
    message.averageMemoryUsage = object.averageMemoryUsage ?? 0;
    message.focusCount = object.focusCount ?? 0;
    return message;
  },
};

function createBaseProcessStatsResponse(): ProcessStatsResponse {
  return { summaries: [], usageByHour: {} };
}

export const ProcessStatsResponse: MessageFns<ProcessStatsResponse> = {
  encode(message: ProcessStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.summaries) {
      ProcessStatsSummary.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.usageByHour).forEach(([key, value]) => {
      ProcessStatsResponse_UsageByHourEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.summaries.push(ProcessStatsSummary.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = ProcessStatsResponse_UsageByHourEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.usageByHour[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessStatsResponse {
    return {
      summaries: globalThis.Array.isArray(object?.summaries)
        ? object.summaries.map((e: any) => ProcessStatsSummary.fromJSON(e))
        : [],
      usageByHour: isObject(object.usageByHour)
        ? Object.entries(object.usageByHour).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ProcessStatsResponse): unknown {
    const obj: any = {};
    if (message.summaries?.length) {
      obj.summaries = message.summaries.map((e) => ProcessStatsSummary.toJSON(e));
    }
    if (message.usageByHour) {
      const entries = Object.entries(message.usageByHour);
      if (entries.length > 0) {
        obj.usageByHour = {};
        entries.forEach(([k, v]) => {
          obj.usageByHour[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessStatsResponse>, I>>(base?: I): ProcessStatsResponse {
    return ProcessStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessStatsResponse>, I>>(object: I): ProcessStatsResponse {
    const message = createBaseProcessStatsResponse();
    message.summaries = object.summaries?.map((e) => ProcessStatsSummary.fromPartial(e)) || [];
    message.usageByHour = Object.entries(object.usageByHour ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseProcessStatsResponse_UsageByHourEntry(): ProcessStatsResponse_UsageByHourEntry {
  return { key: "", value: 0 };
}

export const ProcessStatsResponse_UsageByHourEntry: MessageFns<ProcessStatsResponse_UsageByHourEntry> = {
  encode(message: ProcessStatsResponse_UsageByHourEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ProcessStatsResponse_UsageByHourEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseProcessStatsResponse_UsageByHourEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ProcessStatsResponse_UsageByHourEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ProcessStatsResponse_UsageByHourEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ProcessStatsResponse_UsageByHourEntry>, I>>(
    base?: I,
  ): ProcessStatsResponse_UsageByHourEntry {
    return ProcessStatsResponse_UsageByHourEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ProcessStatsResponse_UsageByHourEntry>, I>>(
    object: I,
  ): ProcessStatsResponse_UsageByHourEntry {
    const message = createBaseProcessStatsResponse_UsageByHourEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseCameraFrameData(): CameraFrameData {
  return { id: "", timestamp: "", imageData: new Uint8Array(0), mimeType: "", metadata: {} };
}

export const CameraFrameData: MessageFns<CameraFrameData> = {
  encode(message: CameraFrameData, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.id !== "") {
      writer.uint32(10).string(message.id);
    }
    if (message.timestamp !== "") {
      writer.uint32(18).string(message.timestamp);
    }
    if (message.imageData.length !== 0) {
      writer.uint32(26).bytes(message.imageData);
    }
    if (message.mimeType !== "") {
      writer.uint32(34).string(message.mimeType);
    }
    Object.entries(message.metadata).forEach(([key, value]) => {
      CameraFrameData_MetadataEntry.encode({ key: key as any, value }, writer.uint32(42).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CameraFrameData {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCameraFrameData();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.id = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.imageData = reader.bytes();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.mimeType = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          const entry5 = CameraFrameData_MetadataEntry.decode(reader, reader.uint32());
          if (entry5.value !== undefined) {
            message.metadata[entry5.key] = entry5.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CameraFrameData {
    return {
      id: isSet(object.id) ? globalThis.String(object.id) : "",
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      imageData: isSet(object.imageData) ? bytesFromBase64(object.imageData) : new Uint8Array(0),
      mimeType: isSet(object.mimeType) ? globalThis.String(object.mimeType) : "",
      metadata: isObject(object.metadata)
        ? Object.entries(object.metadata).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: CameraFrameData): unknown {
    const obj: any = {};
    if (message.id !== "") {
      obj.id = message.id;
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.imageData.length !== 0) {
      obj.imageData = base64FromBytes(message.imageData);
    }
    if (message.mimeType !== "") {
      obj.mimeType = message.mimeType;
    }
    if (message.metadata) {
      const entries = Object.entries(message.metadata);
      if (entries.length > 0) {
        obj.metadata = {};
        entries.forEach(([k, v]) => {
          obj.metadata[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CameraFrameData>, I>>(base?: I): CameraFrameData {
    return CameraFrameData.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CameraFrameData>, I>>(object: I): CameraFrameData {
    const message = createBaseCameraFrameData();
    message.id = object.id ?? "";
    message.timestamp = object.timestamp ?? "";
    message.imageData = object.imageData ?? new Uint8Array(0);
    message.mimeType = object.mimeType ?? "";
    message.metadata = Object.entries(object.metadata ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseCameraFrameData_MetadataEntry(): CameraFrameData_MetadataEntry {
  return { key: "", value: "" };
}

export const CameraFrameData_MetadataEntry: MessageFns<CameraFrameData_MetadataEntry> = {
  encode(message: CameraFrameData_MetadataEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CameraFrameData_MetadataEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCameraFrameData_MetadataEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CameraFrameData_MetadataEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: CameraFrameData_MetadataEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CameraFrameData_MetadataEntry>, I>>(base?: I): CameraFrameData_MetadataEntry {
    return CameraFrameData_MetadataEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CameraFrameData_MetadataEntry>, I>>(
    object: I,
  ): CameraFrameData_MetadataEntry {
    const message = createBaseCameraFrameData_MetadataEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseActivitySummary(): ActivitySummary {
  return {
    timeRange: undefined,
    activityPeriods: [],
    appUsage: {},
    totalScreenshots: 0,
    totalCameraFrames: 0,
    totalByLogger: {},
  };
}

export const ActivitySummary: MessageFns<ActivitySummary> = {
  encode(message: ActivitySummary, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.timeRange !== undefined) {
      TimeRangeRequest.encode(message.timeRange, writer.uint32(10).fork()).join();
    }
    for (const v of message.activityPeriods) {
      ActivityPeriod.encode(v!, writer.uint32(18).fork()).join();
    }
    Object.entries(message.appUsage).forEach(([key, value]) => {
      ActivitySummary_AppUsageEntry.encode({ key: key as any, value }, writer.uint32(26).fork()).join();
    });
    if (message.totalScreenshots !== 0) {
      writer.uint32(32).int32(message.totalScreenshots);
    }
    if (message.totalCameraFrames !== 0) {
      writer.uint32(40).int32(message.totalCameraFrames);
    }
    Object.entries(message.totalByLogger).forEach(([key, value]) => {
      ActivitySummary_TotalByLoggerEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivitySummary {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivitySummary();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.timeRange = TimeRangeRequest.decode(reader, reader.uint32());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.activityPeriods.push(ActivityPeriod.decode(reader, reader.uint32()));
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          const entry3 = ActivitySummary_AppUsageEntry.decode(reader, reader.uint32());
          if (entry3.value !== undefined) {
            message.appUsage[entry3.key] = entry3.value;
          }
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.totalScreenshots = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.totalCameraFrames = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = ActivitySummary_TotalByLoggerEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.totalByLogger[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivitySummary {
    return {
      timeRange: isSet(object.timeRange) ? TimeRangeRequest.fromJSON(object.timeRange) : undefined,
      activityPeriods: globalThis.Array.isArray(object?.activityPeriods)
        ? object.activityPeriods.map((e: any) => ActivityPeriod.fromJSON(e))
        : [],
      appUsage: isObject(object.appUsage)
        ? Object.entries(object.appUsage).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      totalScreenshots: isSet(object.totalScreenshots) ? globalThis.Number(object.totalScreenshots) : 0,
      totalCameraFrames: isSet(object.totalCameraFrames) ? globalThis.Number(object.totalCameraFrames) : 0,
      totalByLogger: isObject(object.totalByLogger)
        ? Object.entries(object.totalByLogger).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: ActivitySummary): unknown {
    const obj: any = {};
    if (message.timeRange !== undefined) {
      obj.timeRange = TimeRangeRequest.toJSON(message.timeRange);
    }
    if (message.activityPeriods?.length) {
      obj.activityPeriods = message.activityPeriods.map((e) => ActivityPeriod.toJSON(e));
    }
    if (message.appUsage) {
      const entries = Object.entries(message.appUsage);
      if (entries.length > 0) {
        obj.appUsage = {};
        entries.forEach(([k, v]) => {
          obj.appUsage[k] = v;
        });
      }
    }
    if (message.totalScreenshots !== 0) {
      obj.totalScreenshots = Math.round(message.totalScreenshots);
    }
    if (message.totalCameraFrames !== 0) {
      obj.totalCameraFrames = Math.round(message.totalCameraFrames);
    }
    if (message.totalByLogger) {
      const entries = Object.entries(message.totalByLogger);
      if (entries.length > 0) {
        obj.totalByLogger = {};
        entries.forEach(([k, v]) => {
          obj.totalByLogger[k] = Math.round(v);
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivitySummary>, I>>(base?: I): ActivitySummary {
    return ActivitySummary.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivitySummary>, I>>(object: I): ActivitySummary {
    const message = createBaseActivitySummary();
    message.timeRange = (object.timeRange !== undefined && object.timeRange !== null)
      ? TimeRangeRequest.fromPartial(object.timeRange)
      : undefined;
    message.activityPeriods = object.activityPeriods?.map((e) => ActivityPeriod.fromPartial(e)) || [];
    message.appUsage = Object.entries(object.appUsage ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.totalScreenshots = object.totalScreenshots ?? 0;
    message.totalCameraFrames = object.totalCameraFrames ?? 0;
    message.totalByLogger = Object.entries(object.totalByLogger ?? {}).reduce<{ [key: string]: number }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.Number(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseActivitySummary_AppUsageEntry(): ActivitySummary_AppUsageEntry {
  return { key: "", value: 0 };
}

export const ActivitySummary_AppUsageEntry: MessageFns<ActivitySummary_AppUsageEntry> = {
  encode(message: ActivitySummary_AppUsageEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivitySummary_AppUsageEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivitySummary_AppUsageEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivitySummary_AppUsageEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ActivitySummary_AppUsageEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivitySummary_AppUsageEntry>, I>>(base?: I): ActivitySummary_AppUsageEntry {
    return ActivitySummary_AppUsageEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivitySummary_AppUsageEntry>, I>>(
    object: I,
  ): ActivitySummary_AppUsageEntry {
    const message = createBaseActivitySummary_AppUsageEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseActivitySummary_TotalByLoggerEntry(): ActivitySummary_TotalByLoggerEntry {
  return { key: "", value: 0 };
}

export const ActivitySummary_TotalByLoggerEntry: MessageFns<ActivitySummary_TotalByLoggerEntry> = {
  encode(message: ActivitySummary_TotalByLoggerEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(16).int32(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivitySummary_TotalByLoggerEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivitySummary_TotalByLoggerEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivitySummary_TotalByLoggerEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ActivitySummary_TotalByLoggerEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = Math.round(message.value);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivitySummary_TotalByLoggerEntry>, I>>(
    base?: I,
  ): ActivitySummary_TotalByLoggerEntry {
    return ActivitySummary_TotalByLoggerEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivitySummary_TotalByLoggerEntry>, I>>(
    object: I,
  ): ActivitySummary_TotalByLoggerEntry {
    const message = createBaseActivitySummary_TotalByLoggerEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseActivityPeriod(): ActivityPeriod {
  return { startTime: "", endTime: "", primaryActivity: "", appsUsed: {}, activityLevel: 0 };
}

export const ActivityPeriod: MessageFns<ActivityPeriod> = {
  encode(message: ActivityPeriod, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.startTime !== "") {
      writer.uint32(10).string(message.startTime);
    }
    if (message.endTime !== "") {
      writer.uint32(18).string(message.endTime);
    }
    if (message.primaryActivity !== "") {
      writer.uint32(26).string(message.primaryActivity);
    }
    Object.entries(message.appsUsed).forEach(([key, value]) => {
      ActivityPeriod_AppsUsedEntry.encode({ key: key as any, value }, writer.uint32(34).fork()).join();
    });
    if (message.activityLevel !== 0) {
      writer.uint32(41).double(message.activityLevel);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityPeriod {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityPeriod();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.startTime = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.endTime = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.primaryActivity = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          const entry4 = ActivityPeriod_AppsUsedEntry.decode(reader, reader.uint32());
          if (entry4.value !== undefined) {
            message.appsUsed[entry4.key] = entry4.value;
          }
          continue;
        }
        case 5: {
          if (tag !== 41) {
            break;
          }

          message.activityLevel = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityPeriod {
    return {
      startTime: isSet(object.startTime) ? globalThis.String(object.startTime) : "",
      endTime: isSet(object.endTime) ? globalThis.String(object.endTime) : "",
      primaryActivity: isSet(object.primaryActivity) ? globalThis.String(object.primaryActivity) : "",
      appsUsed: isObject(object.appsUsed)
        ? Object.entries(object.appsUsed).reduce<{ [key: string]: number }>((acc, [key, value]) => {
          acc[key] = Number(value);
          return acc;
        }, {})
        : {},
      activityLevel: isSet(object.activityLevel) ? globalThis.Number(object.activityLevel) : 0,
    };
  },

  toJSON(message: ActivityPeriod): unknown {
    const obj: any = {};
    if (message.startTime !== "") {
      obj.startTime = message.startTime;
    }
    if (message.endTime !== "") {
      obj.endTime = message.endTime;
    }
    if (message.primaryActivity !== "") {
      obj.primaryActivity = message.primaryActivity;
    }
    if (message.appsUsed) {
      const entries = Object.entries(message.appsUsed);
      if (entries.length > 0) {
        obj.appsUsed = {};
        entries.forEach(([k, v]) => {
          obj.appsUsed[k] = v;
        });
      }
    }
    if (message.activityLevel !== 0) {
      obj.activityLevel = message.activityLevel;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivityPeriod>, I>>(base?: I): ActivityPeriod {
    return ActivityPeriod.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivityPeriod>, I>>(object: I): ActivityPeriod {
    const message = createBaseActivityPeriod();
    message.startTime = object.startTime ?? "";
    message.endTime = object.endTime ?? "";
    message.primaryActivity = object.primaryActivity ?? "";
    message.appsUsed = Object.entries(object.appsUsed ?? {}).reduce<{ [key: string]: number }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Number(value);
      }
      return acc;
    }, {});
    message.activityLevel = object.activityLevel ?? 0;
    return message;
  },
};

function createBaseActivityPeriod_AppsUsedEntry(): ActivityPeriod_AppsUsedEntry {
  return { key: "", value: 0 };
}

export const ActivityPeriod_AppsUsedEntry: MessageFns<ActivityPeriod_AppsUsedEntry> = {
  encode(message: ActivityPeriod_AppsUsedEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== 0) {
      writer.uint32(17).double(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ActivityPeriod_AppsUsedEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseActivityPeriod_AppsUsedEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 17) {
            break;
          }

          message.value = reader.double();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ActivityPeriod_AppsUsedEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Number(object.value) : 0,
    };
  },

  toJSON(message: ActivityPeriod_AppsUsedEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== 0) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ActivityPeriod_AppsUsedEntry>, I>>(base?: I): ActivityPeriod_AppsUsedEntry {
    return ActivityPeriod_AppsUsedEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ActivityPeriod_AppsUsedEntry>, I>>(object: I): ActivityPeriod_AppsUsedEntry {
    const message = createBaseActivityPeriod_AppsUsedEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? 0;
    return message;
  },
};

function createBaseLoginRequest(): LoginRequest {
  return { username: "", password: "" };
}

export const LoginRequest: MessageFns<LoginRequest> = {
  encode(message: LoginRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
    };
  },

  toJSON(message: LoginRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginRequest>, I>>(base?: I): LoginRequest {
    return LoginRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginRequest>, I>>(object: I): LoginRequest {
    const message = createBaseLoginRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    return message;
  },
};

function createBaseLoginResponse(): LoginResponse {
  return { token: "", success: false, errorMessage: "", userProfile: undefined };
}

export const LoginResponse: MessageFns<LoginResponse> = {
  encode(message: LoginResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.token !== "") {
      writer.uint32(10).string(message.token);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    if (message.userProfile !== undefined) {
      UserProfile.encode(message.userProfile, writer.uint32(34).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoginResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoginResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.token = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.userProfile = UserProfile.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoginResponse {
    return {
      token: isSet(object.token) ? globalThis.String(object.token) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      userProfile: isSet(object.userProfile) ? UserProfile.fromJSON(object.userProfile) : undefined,
    };
  },

  toJSON(message: LoginResponse): unknown {
    const obj: any = {};
    if (message.token !== "") {
      obj.token = message.token;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.userProfile !== undefined) {
      obj.userProfile = UserProfile.toJSON(message.userProfile);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoginResponse>, I>>(base?: I): LoginResponse {
    return LoginResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoginResponse>, I>>(object: I): LoginResponse {
    const message = createBaseLoginResponse();
    message.token = object.token ?? "";
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.userProfile = (object.userProfile !== undefined && object.userProfile !== null)
      ? UserProfile.fromPartial(object.userProfile)
      : undefined;
    return message;
  },
};

function createBaseRegisterRequest(): RegisterRequest {
  return { username: "", password: "", email: "", displayName: "" };
}

export const RegisterRequest: MessageFns<RegisterRequest> = {
  encode(message: RegisterRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.username !== "") {
      writer.uint32(10).string(message.username);
    }
    if (message.password !== "") {
      writer.uint32(18).string(message.password);
    }
    if (message.email !== "") {
      writer.uint32(26).string(message.email);
    }
    if (message.displayName !== "") {
      writer.uint32(34).string(message.displayName);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.password = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterRequest {
    return {
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      password: isSet(object.password) ? globalThis.String(object.password) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
    };
  },

  toJSON(message: RegisterRequest): unknown {
    const obj: any = {};
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.password !== "") {
      obj.password = message.password;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterRequest>, I>>(base?: I): RegisterRequest {
    return RegisterRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterRequest>, I>>(object: I): RegisterRequest {
    const message = createBaseRegisterRequest();
    message.username = object.username ?? "";
    message.password = object.password ?? "";
    message.email = object.email ?? "";
    message.displayName = object.displayName ?? "";
    return message;
  },
};

function createBaseRegisterResponse(): RegisterResponse {
  return { success: false, errorMessage: "", token: "" };
}

export const RegisterResponse: MessageFns<RegisterResponse> = {
  encode(message: RegisterResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.token !== "") {
      writer.uint32(26).string(message.token);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RegisterResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRegisterResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.token = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RegisterResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      token: isSet(object.token) ? globalThis.String(object.token) : "",
    };
  },

  toJSON(message: RegisterResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.token !== "") {
      obj.token = message.token;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RegisterResponse>, I>>(base?: I): RegisterResponse {
    return RegisterResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RegisterResponse>, I>>(object: I): RegisterResponse {
    const message = createBaseRegisterResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.token = object.token ?? "";
    return message;
  },
};

function createBaseUserRequest(): UserRequest {
  return { userId: "" };
}

export const UserRequest: MessageFns<UserRequest> = {
  encode(message: UserRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserRequest {
    return { userId: isSet(object.userId) ? globalThis.String(object.userId) : "" };
  },

  toJSON(message: UserRequest): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserRequest>, I>>(base?: I): UserRequest {
    return UserRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserRequest>, I>>(object: I): UserRequest {
    const message = createBaseUserRequest();
    message.userId = object.userId ?? "";
    return message;
  },
};

function createBaseUserProfile(): UserProfile {
  return { userId: "", username: "", displayName: "", email: "", createdAt: "", settings: {} };
}

export const UserProfile: MessageFns<UserProfile> = {
  encode(message: UserProfile, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.userId !== "") {
      writer.uint32(10).string(message.userId);
    }
    if (message.username !== "") {
      writer.uint32(18).string(message.username);
    }
    if (message.displayName !== "") {
      writer.uint32(26).string(message.displayName);
    }
    if (message.email !== "") {
      writer.uint32(34).string(message.email);
    }
    if (message.createdAt !== "") {
      writer.uint32(42).string(message.createdAt);
    }
    Object.entries(message.settings).forEach(([key, value]) => {
      UserProfile_SettingsEntry.encode({ key: key as any, value }, writer.uint32(50).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.userId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.username = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.displayName = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.email = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.createdAt = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          const entry6 = UserProfile_SettingsEntry.decode(reader, reader.uint32());
          if (entry6.value !== undefined) {
            message.settings[entry6.key] = entry6.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile {
    return {
      userId: isSet(object.userId) ? globalThis.String(object.userId) : "",
      username: isSet(object.username) ? globalThis.String(object.username) : "",
      displayName: isSet(object.displayName) ? globalThis.String(object.displayName) : "",
      email: isSet(object.email) ? globalThis.String(object.email) : "",
      createdAt: isSet(object.createdAt) ? globalThis.String(object.createdAt) : "",
      settings: isObject(object.settings)
        ? Object.entries(object.settings).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
          acc[key] = Boolean(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: UserProfile): unknown {
    const obj: any = {};
    if (message.userId !== "") {
      obj.userId = message.userId;
    }
    if (message.username !== "") {
      obj.username = message.username;
    }
    if (message.displayName !== "") {
      obj.displayName = message.displayName;
    }
    if (message.email !== "") {
      obj.email = message.email;
    }
    if (message.createdAt !== "") {
      obj.createdAt = message.createdAt;
    }
    if (message.settings) {
      const entries = Object.entries(message.settings);
      if (entries.length > 0) {
        obj.settings = {};
        entries.forEach(([k, v]) => {
          obj.settings[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile>, I>>(base?: I): UserProfile {
    return UserProfile.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile>, I>>(object: I): UserProfile {
    const message = createBaseUserProfile();
    message.userId = object.userId ?? "";
    message.username = object.username ?? "";
    message.displayName = object.displayName ?? "";
    message.email = object.email ?? "";
    message.createdAt = object.createdAt ?? "";
    message.settings = Object.entries(object.settings ?? {}).reduce<{ [key: string]: boolean }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.Boolean(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseUserProfile_SettingsEntry(): UserProfile_SettingsEntry {
  return { key: "", value: false };
}

export const UserProfile_SettingsEntry: MessageFns<UserProfile_SettingsEntry> = {
  encode(message: UserProfile_SettingsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== false) {
      writer.uint32(16).bool(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UserProfile_SettingsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUserProfile_SettingsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.value = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UserProfile_SettingsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.Boolean(object.value) : false,
    };
  },

  toJSON(message: UserProfile_SettingsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== false) {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UserProfile_SettingsEntry>, I>>(base?: I): UserProfile_SettingsEntry {
    return UserProfile_SettingsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UserProfile_SettingsEntry>, I>>(object: I): UserProfile_SettingsEntry {
    const message = createBaseUserProfile_SettingsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? false;
    return message;
  },
};

function createBaseLoggerStatusRequest(): LoggerStatusRequest {
  return { loggerNames: [] };
}

export const LoggerStatusRequest: MessageFns<LoggerStatusRequest> = {
  encode(message: LoggerStatusRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.loggerNames) {
      writer.uint32(10).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggerStatusRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggerStatusRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loggerNames.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggerStatusRequest {
    return {
      loggerNames: globalThis.Array.isArray(object?.loggerNames)
        ? object.loggerNames.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: LoggerStatusRequest): unknown {
    const obj: any = {};
    if (message.loggerNames?.length) {
      obj.loggerNames = message.loggerNames;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoggerStatusRequest>, I>>(base?: I): LoggerStatusRequest {
    return LoggerStatusRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoggerStatusRequest>, I>>(object: I): LoggerStatusRequest {
    const message = createBaseLoggerStatusRequest();
    message.loggerNames = object.loggerNames?.map((e) => e) || [];
    return message;
  },
};

function createBaseLoggerStatus(): LoggerStatus {
  return { name: "", enabled: false, running: false, lastActive: "", dataPoints: 0, error: "" };
}

export const LoggerStatus: MessageFns<LoggerStatus> = {
  encode(message: LoggerStatus, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.name !== "") {
      writer.uint32(10).string(message.name);
    }
    if (message.enabled !== false) {
      writer.uint32(16).bool(message.enabled);
    }
    if (message.running !== false) {
      writer.uint32(24).bool(message.running);
    }
    if (message.lastActive !== "") {
      writer.uint32(34).string(message.lastActive);
    }
    if (message.dataPoints !== 0) {
      writer.uint32(40).int64(message.dataPoints);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggerStatus {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggerStatus();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.name = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enabled = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.running = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.lastActive = reader.string();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.dataPoints = longToNumber(reader.int64());
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggerStatus {
    return {
      name: isSet(object.name) ? globalThis.String(object.name) : "",
      enabled: isSet(object.enabled) ? globalThis.Boolean(object.enabled) : false,
      running: isSet(object.running) ? globalThis.Boolean(object.running) : false,
      lastActive: isSet(object.lastActive) ? globalThis.String(object.lastActive) : "",
      dataPoints: isSet(object.dataPoints) ? globalThis.Number(object.dataPoints) : 0,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: LoggerStatus): unknown {
    const obj: any = {};
    if (message.name !== "") {
      obj.name = message.name;
    }
    if (message.enabled !== false) {
      obj.enabled = message.enabled;
    }
    if (message.running !== false) {
      obj.running = message.running;
    }
    if (message.lastActive !== "") {
      obj.lastActive = message.lastActive;
    }
    if (message.dataPoints !== 0) {
      obj.dataPoints = Math.round(message.dataPoints);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoggerStatus>, I>>(base?: I): LoggerStatus {
    return LoggerStatus.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoggerStatus>, I>>(object: I): LoggerStatus {
    const message = createBaseLoggerStatus();
    message.name = object.name ?? "";
    message.enabled = object.enabled ?? false;
    message.running = object.running ?? false;
    message.lastActive = object.lastActive ?? "";
    message.dataPoints = object.dataPoints ?? 0;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseLoggerStatusResponse(): LoggerStatusResponse {
  return { loggers: [], systemStats: {} };
}

export const LoggerStatusResponse: MessageFns<LoggerStatusResponse> = {
  encode(message: LoggerStatusResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.loggers) {
      LoggerStatus.encode(v!, writer.uint32(10).fork()).join();
    }
    Object.entries(message.systemStats).forEach(([key, value]) => {
      LoggerStatusResponse_SystemStatsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggerStatusResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggerStatusResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loggers.push(LoggerStatus.decode(reader, reader.uint32()));
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = LoggerStatusResponse_SystemStatsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.systemStats[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggerStatusResponse {
    return {
      loggers: globalThis.Array.isArray(object?.loggers)
        ? object.loggers.map((e: any) => LoggerStatus.fromJSON(e))
        : [],
      systemStats: isObject(object.systemStats)
        ? Object.entries(object.systemStats).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: LoggerStatusResponse): unknown {
    const obj: any = {};
    if (message.loggers?.length) {
      obj.loggers = message.loggers.map((e) => LoggerStatus.toJSON(e));
    }
    if (message.systemStats) {
      const entries = Object.entries(message.systemStats);
      if (entries.length > 0) {
        obj.systemStats = {};
        entries.forEach(([k, v]) => {
          obj.systemStats[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoggerStatusResponse>, I>>(base?: I): LoggerStatusResponse {
    return LoggerStatusResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoggerStatusResponse>, I>>(object: I): LoggerStatusResponse {
    const message = createBaseLoggerStatusResponse();
    message.loggers = object.loggers?.map((e) => LoggerStatus.fromPartial(e)) || [];
    message.systemStats = Object.entries(object.systemStats ?? {}).reduce<{ [key: string]: string }>(
      (acc, [key, value]) => {
        if (value !== undefined) {
          acc[key] = globalThis.String(value);
        }
        return acc;
      },
      {},
    );
    return message;
  },
};

function createBaseLoggerStatusResponse_SystemStatsEntry(): LoggerStatusResponse_SystemStatsEntry {
  return { key: "", value: "" };
}

export const LoggerStatusResponse_SystemStatsEntry: MessageFns<LoggerStatusResponse_SystemStatsEntry> = {
  encode(message: LoggerStatusResponse_SystemStatsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): LoggerStatusResponse_SystemStatsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseLoggerStatusResponse_SystemStatsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): LoggerStatusResponse_SystemStatsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: LoggerStatusResponse_SystemStatsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<LoggerStatusResponse_SystemStatsEntry>, I>>(
    base?: I,
  ): LoggerStatusResponse_SystemStatsEntry {
    return LoggerStatusResponse_SystemStatsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<LoggerStatusResponse_SystemStatsEntry>, I>>(
    object: I,
  ): LoggerStatusResponse_SystemStatsEntry {
    const message = createBaseLoggerStatusResponse_SystemStatsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseToggleLoggerRequest(): ToggleLoggerRequest {
  return { loggerName: "", enable: false };
}

export const ToggleLoggerRequest: MessageFns<ToggleLoggerRequest> = {
  encode(message: ToggleLoggerRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.loggerName !== "") {
      writer.uint32(10).string(message.loggerName);
    }
    if (message.enable !== false) {
      writer.uint32(16).bool(message.enable);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleLoggerRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleLoggerRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loggerName = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.enable = reader.bool();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToggleLoggerRequest {
    return {
      loggerName: isSet(object.loggerName) ? globalThis.String(object.loggerName) : "",
      enable: isSet(object.enable) ? globalThis.Boolean(object.enable) : false,
    };
  },

  toJSON(message: ToggleLoggerRequest): unknown {
    const obj: any = {};
    if (message.loggerName !== "") {
      obj.loggerName = message.loggerName;
    }
    if (message.enable !== false) {
      obj.enable = message.enable;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToggleLoggerRequest>, I>>(base?: I): ToggleLoggerRequest {
    return ToggleLoggerRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleLoggerRequest>, I>>(object: I): ToggleLoggerRequest {
    const message = createBaseToggleLoggerRequest();
    message.loggerName = object.loggerName ?? "";
    message.enable = object.enable ?? false;
    return message;
  },
};

function createBaseToggleLoggerResponse(): ToggleLoggerResponse {
  return { success: false, errorMessage: "", status: undefined };
}

export const ToggleLoggerResponse: MessageFns<ToggleLoggerResponse> = {
  encode(message: ToggleLoggerResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(18).string(message.errorMessage);
    }
    if (message.status !== undefined) {
      LoggerStatus.encode(message.status, writer.uint32(26).fork()).join();
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ToggleLoggerResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseToggleLoggerResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.status = LoggerStatus.decode(reader, reader.uint32());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ToggleLoggerResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      status: isSet(object.status) ? LoggerStatus.fromJSON(object.status) : undefined,
    };
  },

  toJSON(message: ToggleLoggerResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.status !== undefined) {
      obj.status = LoggerStatus.toJSON(message.status);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ToggleLoggerResponse>, I>>(base?: I): ToggleLoggerResponse {
    return ToggleLoggerResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ToggleLoggerResponse>, I>>(object: I): ToggleLoggerResponse {
    const message = createBaseToggleLoggerResponse();
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.status = (object.status !== undefined && object.status !== null)
      ? LoggerStatus.fromPartial(object.status)
      : undefined;
    return message;
  },
};

function createBaseSnapshotRequest(): SnapshotRequest {
  return { loggers: [], options: {} };
}

export const SnapshotRequest: MessageFns<SnapshotRequest> = {
  encode(message: SnapshotRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    for (const v of message.loggers) {
      writer.uint32(10).string(v!);
    }
    Object.entries(message.options).forEach(([key, value]) => {
      SnapshotRequest_OptionsEntry.encode({ key: key as any, value }, writer.uint32(18).fork()).join();
    });
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapshotRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.loggers.push(reader.string());
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          const entry2 = SnapshotRequest_OptionsEntry.decode(reader, reader.uint32());
          if (entry2.value !== undefined) {
            message.options[entry2.key] = entry2.value;
          }
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotRequest {
    return {
      loggers: globalThis.Array.isArray(object?.loggers) ? object.loggers.map((e: any) => globalThis.String(e)) : [],
      options: isObject(object.options)
        ? Object.entries(object.options).reduce<{ [key: string]: string }>((acc, [key, value]) => {
          acc[key] = String(value);
          return acc;
        }, {})
        : {},
    };
  },

  toJSON(message: SnapshotRequest): unknown {
    const obj: any = {};
    if (message.loggers?.length) {
      obj.loggers = message.loggers;
    }
    if (message.options) {
      const entries = Object.entries(message.options);
      if (entries.length > 0) {
        obj.options = {};
        entries.forEach(([k, v]) => {
          obj.options[k] = v;
        });
      }
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnapshotRequest>, I>>(base?: I): SnapshotRequest {
    return SnapshotRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnapshotRequest>, I>>(object: I): SnapshotRequest {
    const message = createBaseSnapshotRequest();
    message.loggers = object.loggers?.map((e) => e) || [];
    message.options = Object.entries(object.options ?? {}).reduce<{ [key: string]: string }>((acc, [key, value]) => {
      if (value !== undefined) {
        acc[key] = globalThis.String(value);
      }
      return acc;
    }, {});
    return message;
  },
};

function createBaseSnapshotRequest_OptionsEntry(): SnapshotRequest_OptionsEntry {
  return { key: "", value: "" };
}

export const SnapshotRequest_OptionsEntry: MessageFns<SnapshotRequest_OptionsEntry> = {
  encode(message: SnapshotRequest_OptionsEntry, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.key !== "") {
      writer.uint32(10).string(message.key);
    }
    if (message.value !== "") {
      writer.uint32(18).string(message.value);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapshotRequest_OptionsEntry {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotRequest_OptionsEntry();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.key = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.value = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotRequest_OptionsEntry {
    return {
      key: isSet(object.key) ? globalThis.String(object.key) : "",
      value: isSet(object.value) ? globalThis.String(object.value) : "",
    };
  },

  toJSON(message: SnapshotRequest_OptionsEntry): unknown {
    const obj: any = {};
    if (message.key !== "") {
      obj.key = message.key;
    }
    if (message.value !== "") {
      obj.value = message.value;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnapshotRequest_OptionsEntry>, I>>(base?: I): SnapshotRequest_OptionsEntry {
    return SnapshotRequest_OptionsEntry.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnapshotRequest_OptionsEntry>, I>>(object: I): SnapshotRequest_OptionsEntry {
    const message = createBaseSnapshotRequest_OptionsEntry();
    message.key = object.key ?? "";
    message.value = object.value ?? "";
    return message;
  },
};

function createBaseSnapshotResponse(): SnapshotResponse {
  return { snapshotId: "", success: false, errorMessage: "", triggeredLoggers: [] };
}

export const SnapshotResponse: MessageFns<SnapshotResponse> = {
  encode(message: SnapshotResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.snapshotId !== "") {
      writer.uint32(10).string(message.snapshotId);
    }
    if (message.success !== false) {
      writer.uint32(16).bool(message.success);
    }
    if (message.errorMessage !== "") {
      writer.uint32(26).string(message.errorMessage);
    }
    for (const v of message.triggeredLoggers) {
      writer.uint32(34).string(v!);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): SnapshotResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseSnapshotResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.snapshotId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.errorMessage = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.triggeredLoggers.push(reader.string());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): SnapshotResponse {
    return {
      snapshotId: isSet(object.snapshotId) ? globalThis.String(object.snapshotId) : "",
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      errorMessage: isSet(object.errorMessage) ? globalThis.String(object.errorMessage) : "",
      triggeredLoggers: globalThis.Array.isArray(object?.triggeredLoggers)
        ? object.triggeredLoggers.map((e: any) => globalThis.String(e))
        : [],
    };
  },

  toJSON(message: SnapshotResponse): unknown {
    const obj: any = {};
    if (message.snapshotId !== "") {
      obj.snapshotId = message.snapshotId;
    }
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.errorMessage !== "") {
      obj.errorMessage = message.errorMessage;
    }
    if (message.triggeredLoggers?.length) {
      obj.triggeredLoggers = message.triggeredLoggers;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<SnapshotResponse>, I>>(base?: I): SnapshotResponse {
    return SnapshotResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<SnapshotResponse>, I>>(object: I): SnapshotResponse {
    const message = createBaseSnapshotResponse();
    message.snapshotId = object.snapshotId ?? "";
    message.success = object.success ?? false;
    message.errorMessage = object.errorMessage ?? "";
    message.triggeredLoggers = object.triggeredLoggers?.map((e) => e) || [];
    return message;
  },
};

function bytesFromBase64(b64: string): Uint8Array {
  const bin = globalThis.atob(b64);
  const arr = new Uint8Array(bin.length);
  for (let i = 0; i < bin.length; ++i) {
    arr[i] = bin.charCodeAt(i);
  }
  return arr;
}

function base64FromBytes(arr: Uint8Array): string {
  const bin: string[] = [];
  arr.forEach((byte) => {
    bin.push(globalThis.String.fromCharCode(byte));
  });
  return globalThis.btoa(bin.join(""));
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isObject(value: any): boolean {
  return typeof value === "object" && value !== null;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
